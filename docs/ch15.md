# Capítulo 15 Optimización del rendimiento de las aplicaciones

## `Core Web Vitals`

`CWV` es un conjunto de métricas que ayudan a medir el rendimiento de una aplicación web. Forma parte de `Web Vitals`, una iniciativa liderada por Google que unifica varias guías y herramientas para medir el rendimiento en páginas web. Cada métrica se centra en un aspecto específico de la experiencia del usuario, incluyendo la carga, la interactividad y la estabilidad visual de una página web:

* `Largest Contentful Paint` (`LCP`): Mide la velocidad de carga de una página web calculando cuánto tiempo tarda en renderizarse el elemento más grande de la página. Un valor `LCP` rápido indica que la página está disponible para el usuario rápidamente.
* `Interaction to Next Paint` (`INP`): Mide la capacidad de respuesta de una página web calculando cuánto tiempo tarda en responder a las interacciones del usuario y proporcionar información visual. Un valor `INP` bajo indica que la página responde al usuario rápidamente.
* `Cumulative Layout Shift` (`CLS`): Mide la estabilidad de la interfaz de usuario en una página web calculando la frecuencia con la que se producen cambios de `layout` no deseados. Un cambio de `layout` suele ocurrir cuando los elementos `HTML` se mueven en el `DOM` debido a la carga dinámica o asíncrona. Un valor `CLS` bajo indica que la página es visualmente estable.

`Web Vitals` contiene métricas adicionales que contribuyen al conjunto `CWV` existente al medir un área más amplia o de nicho de la experiencia de usuario, como `First Contentful Paint` (`FCP`) y `Time to First Byte` (`TTFB`).

El valor de cada métrica `CWV` se clasifica en las siguientes categorías:

* BUENO (verde)
* NECESITA MEJORAS (naranja)
* POBRE (rojo)


Es posible medir las `CWV` de las siguientes maneras:

* En el campo: Se pueden utilizar herramientas como `PageSpeed Insights` y `Chrome User Experience Report` mientras la aplicación web se ejecuta en producción.
* Programáticamente en `JavaScript`: Se pueden utilizar las `API` web estándar o bibliotecas de terceros como `web-vitals`.
* En el laboratorio: Se pueden utilizar herramientas como `Chrome DevTools` y `Lighthouse` durante la construcción de la aplicación web en la fase de desarrollo.

En este capítulo nos centraremos en medir el rendimiento con `Lighthouse`.

Si pulsamos sobre la pestaña `Lighthouse` en `Chrome DevTools`, podemos ejecutar una auditoría de rendimiento de la aplicación. `Lighthouse` generará un informe que incluye las métricas `CWV` y otras métricas de rendimiento, como el tiempo de carga, el tiempo de interacción y la estabilidad visual. También proporciona sugerencias para mejorar el rendimiento de la aplicación.

Si elegimos únicamente el informe de rendimiento (`Performance`), `Lighthouse` muestra un pobre resultado. En cualquier caso, este resultado variará en función de las capacidades del equipo y de las extensiones instaladas en el navegador. Por ello, en conveniente ejecutarlo en una ventana de incógnito y con las extensiones desactivadas (ya que algunas pueden estar activas incluso en este modo).

## Renderizado de aplicaciones Server-Side Rendering (SSR)

`SSR` es una técnica en el desarrollo web que mejora el rendimiento y la seguridad de las aplicaciones de las siguientes maneras:

* Mejora el rendimiento de carga al renderizar la aplicación en el servidor y eliminar el contenido `HTML` inicial entregado al cliente. El servidor entrega el `HTML` inicial al cliente, que puede analizar y cargar mientras espera que se descargue el contenido `JavaScript`.
* Mejora la optimización para motores de búsqueda (`SEO`) al hacer que la aplicación sea detectable e indexable por los rastreadores web. El `SEO` proporciona contenido significativo cuando se comparte en aplicaciones de terceros, como plataformas de redes sociales.
* Mejora las métricas `CWV` relacionadas con la velocidad de carga y la estabilidad de la interfaz de usuario, como `LCP`, `FCP` y `CLS`.
* Mejora la seguridad al añadir `CSP nonces` a las aplicaciones `Angular`.

La opción por defecto en `Angular CLI` es `CSR`, que renderiza la aplicación en el cliente. Para habilitar `SSR` en una aplicación que lo tenga desactivado:

```bash
ng add @angular/ssr
```

Una vez completada la instalación, `Angular CLI` crea los siguientes archivos:

* `main.server.ts`: Se utiliza para arrancar la aplicación en el servidor utilizando una configuración específica.
* `app.config.server.ts`: Contiene la configuración para la aplicación renderizada en el servidor. Exporta una variable `config`, que contiene una versión fusionada de los archivos de configuración de la aplicación cliente y servidor.
* `server.ts`: Configura e inicia un servidor `Node.js Express` que renderiza la aplicación `Angular` en el servidor. Utiliza la clase `CommonEngine` del paquete `@angular/ssr` para iniciar la aplicación `Angular`.

Además, el comando realizará las siguientes modificaciones en el espacio de trabajo de `Angular CLI`:

* Añade las opciones necesarias en la sección `build` del archivo `angular.json` para ejecutar la aplicación `Angular` en `SSR` y `SSG`.
* Añade las entradas necesarias en las propiedades `files` y `types` del archivo `tsconfig.app.json` para que el compilador `TypeScript` pueda identificar los archivos creados para el servidor.
* Añade los `scripts` y dependencias necesarios en el archivo `package.json`.
* Añade `provideClientHydration` en el archivo `src\app\app.config.ts` para habilitar la hidratación en la aplicación `Angular`. La hidratación es el proceso de restaurar la aplicación renderizada en el servidor al cliente. Se dará más información sobre la hidratación más adelante en el capítulo.

Para compilar la aplicación:

```bash
ng build
```

El comando anterior genera paquetes de navegador y servidor dentro de la carpeta
`dist\my-app` y prerenderiza rutas estáticas. Aprenderemos más sobre el prerenderizado
en la sección "Prerenderizado de aplicaciones SSG".

Para ejecutar la aplicación SSR:

```bash
npm run serve:ssr:my-app
```

Ahora el rendimiento de la aplicación debería ser mucho mejor. Si volvemos a ejecutar `Lighthouse`, veremos que las métricas `CWV` han mejorado significativamente.

Angular SSR es una buena opción cuando se necesita `fetch` datos del servidor y
mostrarlos estáticamente en un sitio web. Sin embargo, hay casos en los que SSR no es
beneficioso, como cuando una aplicación se basa en la entrada de datos y tiene una gran
cantidad de `input` de usuario.

## Anulación de SSR en aplicaciones Angular

La hidratación es una característica importante habilitada por defecto en las aplicaciones
Angular SSR. Mejora el rendimiento general de la aplicación al manejar la creación del
DOM en el cliente de manera eficiente. El cliente puede reutilizar la estructura del DOM
de la aplicación renderizada en el lado del servidor en lugar de crearla desde cero y forzar
un parpadeo de la interfaz de usuario, lo que afecta las métricas de CWV como LCP y CLS.
El proceso de hidratación fallará en los siguientes casos:

* Cuando se intenta manipular el DOM a través de una `API` nativa del navegador, como
  `window` o `document`, ya sea directamente o usando una librería de terceros.
* Cuando las `template` de los componentes no tienen una sintaxis HTML válida.

Se pueden superar los problemas anteriores aplicando las siguientes mejores prácticas:

* Usar las `API` de Angular para detectar la plataforma en la que se ejecuta la aplicación
  antes de interactuar con el DOM.
* Omitir la hidratación para componentes Angular específicos.

Por ejemplo, la información del `copyright` en el pie de página no se está mostrando adecuadamente. Esto ocurre porque el `copyright` se genera dinámicamente en el cliente en el fichero `copyright.directive.ts`. El problema se produce porque no hay DOM en el servidor.

Para arreglarlo, se puede omitir la hidratación para el componente del `copyright` utilizando la directiva `ngSkipHydration`.

El componente `<mat-toolbar>` y sus componentes hijos no se hidratarán. Esto significa
que Angular los creará desde cero cuando la versión SSR de la aplicación esté lista.

Sin embargo, saltarse la hidratación debe considerarse una solución temporal. Se utiliza
provisionalmente en los casos en que la hidratación no puede activarse. Se recomienda
refactorizar el código para que la aplicación pueda beneficiarse de las capacidades de
hidratación.
